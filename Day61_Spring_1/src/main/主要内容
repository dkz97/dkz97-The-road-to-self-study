1.Spring的概述
    Spring是什么
    Spring的两大核心
    Spring体系结构

2.程序的耦合和解耦
    工厂模式的解耦

3.IOC概念和Spring中的IOC
    基于xml环境的IOC搭建

4.依赖注入
    (Dependency Injection)






1. Spring概述

    Spring是什么: Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，
        以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，
        提供了展现层 SpringMVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术
        还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。

    Spring的优势:
        1.方便解耦
            提供IOC容器，将对象之间的关系给Spring控制，避免对象间的过度耦合

        2.AOP的变成支持
            使用Spring的AOP，可以面向切面编程

        3.声明式事务支持
            灵活的方式进行事务管理

        4.方便程序的测试
            可以用非容器依赖的编程方式进行几乎所有的测试工作

        5.方便集成各种优秀框架
            Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。

        6.降低 JavaEE API 的使用难度
            Spring 对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层

        7.Java 源码是经典学习范例
            Spring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。




二.程序的耦合和解耦

    模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差

    简单来说就是，关联越密切，耦合度越高，模块的独立性就越差，比如少了一个就运行不了模块的意思

    （1）内容耦合
        当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另、一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。

    （2）公共耦合
        两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。

    （3）外部耦合
        一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。

    （4）控制耦合
        一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。

    （5）标记耦合
        若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。

    （6）数据耦合
        模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，
            系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。
    （7）非直接耦合
        两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。

    总结：
        耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须
            存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。



    解耦:
        使用工厂类模式进行解耦

        比如servlet需要new service 的时候才可以使用service的对象
            所以可以创建一个Bean工厂类，里面设置方法，可以通过配置文件， 传入名字参数，然后获取配置文件的对应参数的全类名
                然后通过Class.forName，class流，来获取Bean对象。 这个就可以实现解耦




三.IOC的概念

    控制反转-Inversion Of Control:
        之前获取对象，都是直接new来获取，主动获取资源

        如果使用工厂类，就是找工厂类，让工厂内内部获取资源，然后工厂类帮我们找到资源后再返回给我们，是被动获取资源

        工厂就相当于一个容器，Map<key,object> 我们给定名字，工厂返回对象

        控制反转就是，把创建对象的权利交给框架

        明确 ioc 的作用：
            削减计算机程序的耦合(解除我们代码中的依赖关系)


四.使用Spring的IOC来解决程序耦合

    环境的导入：
        1. 导入jar包
        2. 编写bean.xml  (导入头文件)
        3. 在bean.xml中填写映射配置

    IOC的使用
        1. 获取核心容器对象 (容器里面都是装的需要spring创建对象的id 和Bean对象全类名)
            ApplicationContext ac = new ClassPathXmlApplicationContext(" 设置的bean.xml ")

        2. 使用核心容器对象,根据id获取Bean对象
            Object getBean("id的值",需要转换的类的class流)

        3. 使用Bean对象




    ApplicationContext 的三个实现类:
        ClassPathXmlApplicationContext(): 基于加载类路径下的配置文件，要求配置文件必须在类路径下
        FileSystemXmlApplicationContext(): 基于系统路径下的配置文件，传入的路径也是系统路径(要有加载权限)
        AnnotationConfigApplicationContext(): 在注解中读取，创建容器



    核心容器的两个接口
        ApplicationContext:   单例对象适用(常用,并且自己也有延迟加载的属性)
            当适用这个接口去创建核心容器的话，一创建核心容器后，会立刻把容器内的Bean对象全部加载出来

        BeanFactory:    多例对象适用
            使用的是延迟加载的情况,创建容器后，不会立刻加载对象，当使用id获取对象的时候才会创建对象




五. bean.xml配置

    1.创建bean的三种方式
        1. 使用默认的构造函数创建
        <bean id ="" class = "" > </bean>
            只有id 和class属性, 如果创建对象的话，默认使用空构造方法，但是如果类没有空构造方法，就无法创建


        2.使用普通工厂中的方法创建对象(就是类中有个方法，return new 对象的，就可以配置来调用那个方法创建对象)
        <bean id="" factory-bean = ""  factory-method=""></bean>
            factory-bean: 值为其他的<bean>的id，主要是创建这个类的对象
            factory-method: 值为类连有的方法的名称


        3.使用工厂中的静态方法创建对象，类似二，不过方法变成了静态方法
        <bean id="" class=""   factory-method=""></bean>
            class: 需要创建的类的全类名
            factory-method: 方法名称


    2.bean的作用范围:
        bean 默认情况下是使用类的无参构造方法

        bean的属性:
            id : 给对象在容器中的唯一标示，用于获取对象
            class : 指定类的全类名，用于反射创建对象，默认使用无参构造方法

            scope: 指定对象的作用范围
                singleton: 默认值, 单例的
                prototype: 多例的，类似与延迟加载
                request: web项目的，spring创建一个对象后，将对象存入到request中
                session: web项目的,spring创建一个对象后，将对象存入到session中
                global session:  WEB 项目中,应用在 Portlet 环境.如果没有 Portlet(相当于多个服务器环境) 环境那么globalSession 相当于 session.

            init-method：指定类中的初始化方法名称。
            destroy-method：指定类中销毁方法名称。


            注意:
            singleton:  一个应用只有一个对象，作用范围就是整个引用
                生命周期:
                    出生: 核心对象容器创建的时候，就出生创建
                    活着: 只要容器没有销毁，那就一直活着
                    死亡: 只要容器销毁了，这个对象也销毁

            prototype: 每次访问对象的时候，都会创建新的对象
                生命周期:
                    出生: 当需要创建对象的时候，才出生出生创建
                    活着: 只要对象在使用的时候，就一直活着
                    死亡: 对象长时间不用的时候，根据java的垃圾回收机制，一起回收


六.Spring的依赖注入

    依赖注入: Dependency Injection

    IOC作用: 减少程序间的耦合

    依赖关系的管理:
        主要是给spring来维护，我们是需要到xml中进行以配置文件的说明，这就叫依赖注入

    依赖关系的维护 就称之为 依赖注入


    依赖注入:
        注入的数据有三类:
            基本类型和String
            其他的bean类型(需要先在配置文件活着注解中配置过的bean)
            复杂类型/集合类型

        注入的方式:
            主要是对其进行数据的写入，可以在类中定义构造方法，然后就可以使用构造函数注入，也可以在类中定义set方法，然后就可以在xml
                中进行set方法的注入

            1.构造函数提供
            2.set方法提供
            3.注解提供


        1.构造函数注入:
            使用标签 <constructor-arg>
                在<bean>标签内部

            属性:
                type: 用于指定注入数据的数据类型，该数据类型也是构造函数中某个或者某些参数的类型
                index: 输入的是索引，输入索引，根据参数列表的索引进行参数的传递
                name: 根据参数的名称进行参数的传递

                value: 参数的值，提供基本类型和String类型
                ref:  用于指定其他bean类型的数据，要在spring ioc核心容器出现过的bean对象

            优点:
                获取bean对象的时候，如果注入数据是必须的操作的话，使用这个还挺方便的
            缺点:
                改变了bean对象的实例化方式,如果创建对象的时候用不到这些数据，还是要提供


        2.set方法注入:      要在类对象中使用getter 和setter方法才行
            涉及的标签: property
            出现的位置: bean内部

            属性:
                name: 参数名称
                value: 参数的值，基本类型和String类型
                ref: 其他bean类型的值，需要在xml先配置好

            优势:
                创建没有明确界限，可以空参数构造也可以当前参数构造
            缺点:
                如果某个成员必须有值的化，获取对象有可能没执行set方法



        复杂类型/集合的注入:

            涉及的标签: property  属性为name 就是参数名称


            以下的标签都在property中

                用于给list结构集合注入的标签
                    list array set      这三个标签的内部都是value标签来传值

                用于给map结构集合注入的标签
                    <map>
                        <entry key="map1" value="map1"></entry>
                    </map>

                    <props>
                        <prop key="prop">pro1</prop>
                    </props>

                   
                    props map
                结构相同标签可以互换

