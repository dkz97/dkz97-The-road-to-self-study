1.多表查询
2.事务
3.DCL





一.多表查询
    多表查询分类:
        1.内连接:
            隐式内连接
            显示内连接
        2.外连接:
            左外连接
            右外连接

    笛卡尔积现象:
        两个集合A和B，取这两个集合的所有组成情况
        要完成多表查询，就不能发生笛卡尔积现象，要消除无用数据


    1.内连接查询
        1.隐式内连接
            语法: SELECT 表名1.字段列表 表名2.字段列表... FROM 表名1,表名2... WHERE 条件

        2.显式内连接
            语法: SELECT 表名1.字段列表... FROM 表名1 [INNER] JOIN 表明2 ON 条件

        内连接查询基本情况:
            1.查询的字段
            2.从哪些表查询
            3.查询的条件是什么


    2.外连接查询:
        1.左外连接查询
            SELECT 字段 FROM 表1 left [outer] join 表2 on 条件;
            主要的意思就是:左边的数据查询所有，右边的数据查询条件的，然后再取交集的部分
        2.右外连接查询
            SELECT 字段 FROM 表1 right [outer] join 表2 on 条件;
            查询右边的所有数据和左边数据根据条件的交集部分


    3.子查询
        概念:
            就是查询语句中嵌套另一个查询语句，就是子查询

        1.子查询的结果是单行单列的(就是一个数据的)
            那子查询就可以作为判断语句放在最后面，用运算符判断

            比如查询员工最高工资的人
                那就可以把子查询设置为，查询最高工资，然后在主查询的WHERE条件中=子查询，就相当于等于最高工资，这样就行了

        2.子查询的结果是多行单列的(单列多个数据)
            可以用in(子查询) 来进行判断

            比如子查询的数据是1234， 如果从1-9中查询出来，就相当于WHERE xxx in(1,2,3,4) ，用in来判断

        3.子查询的结果是多行多列的
            那子查询就可以作为一张表来一起进入查询

            不过实用性的话还不如直接用普通内连接


2.事务
    1.事务的基本介绍
        概念:
            如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败
            是一系列操作，这些操作作为一个整体来向系统提交
            mysql中的事务是默认提交的，打开一个mysql就相当于开了一个事务

        操作:
            1.开始事务: start transaction;
                当执行这个语句之后，后面的执行语句都会在被事务管理中，数据都是在内存中运作
            2.回滚:rollback;
                执行这个语句后，全部回滚，数据返回到事务开始之前.
            3.提交:commit
                执行语句后，数据提交，内存数据转换为硬盘中
                注意:
                    1.mysql中默认自动提交，一条DML就会自动提交一次
                    2.oracle中默认手动提交，需要先开启事务，再提交
                修改事务的默认提交方式:
                    select @@autocommit = 0/1; -- 1代表自动提交，0 代表手动提交

    2.事务的四大特征
        1.原子性: 不可分割的最小操作单位，要么同时成功，要么同时失败
        2.持久性: 当事务提交或者回滚后，数据会永久化保存
        3.隔离性: 多个事务之间相互独立，一个事务的内部操作和另外一个事务是不相关的
        4.一致性: 事务操作前后，数据总量不变，关注于事务内部数据的可视性


    3.事务的隔离性
        概念:不同的事务是有隔离的，是独立的，如果不同的事务操作同一个数据，会引发一些问题，需要设计不同的隔离级别来改变这个问题

        不同事务之间存在的问题
            1.脏读:当两个事务同时操作一个数据，一个事务操作数据后，但是还没提交，另外一个事务还是看到数据的修改情况，这就是脏读
            2.不可重复读(虚读):两个事务操作同一个数据，在一个事务中，因为另外一个事务改变了数据导致两次读取的数据不一样。
            3.幻读:就是事务1和事务2都进行操作，本来事务1是查询30条数据，但是事务2增加了一条数据，事务1再次查询就多了一条数据，就相当于幻读

        隔离级别:
            1.read uncommitted: 读未提交
                产生问题: 脏读，不可重复读，幻读

            2.read committed=: 读已提交(Oracle默认)
                产生问题: 不可重复读，幻读

            3.repeatable read: 可重复度(MySQL默认)
                产生问题: 幻读

            4.serializable: 串行化
                解决所有问题

            注意:隔离级别越高安全性越高，效率越低
            查询隔离级别:
                select @@tx_isolation;
            设置隔离级别:
                set global transaction isolation level 级别字符串;


三.SQL语法中的DCL
    1.基本概念: 管理数据库用户和授权的

        1.管理用户
            1.添加用户:
                CREATE USER '用户名'@'主机名' identified by '密码';
            2.删除用户
                DROP USER '用户名'@'主机名';
            3.修改用户密码:

            4.查询用户:
                1.切换到mysql数据库
                2.select * from user;

            通配符: % 表示可以在任意主机上使用用户登陆数据库

        2.权限管理
            1.查询权限:
                show grants for '用户名'@'主机名';

            2.授予权限
                grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';
                如果授予全部权限
                grant all on *.* to 'xxx'@'xxx';

            3.撤销权限
                revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';

